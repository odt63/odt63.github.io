[{"title":"CSP-J2022 T2 解密","url":"/2022/11/12/cspj2022-t2-sol/","content":"在whk上咕咕的我终于回来了，这用的是数学方法。\nSolution\n首先 (pi−1)(qi−1)+1(p_i-1)(q_i-1)+1(pi​−1)(qi​−1)+1 什么也看不出来，先拆个括号，就会变成 pi⋅qi−pi−qi+2p_i·q_i-p_i-q_i+2pi​⋅qi​−pi​−qi​+2 这个样子，已知  pi⋅qi=nip_i·q_i=n_ipi​⋅qi​=ni​ 且 pi⋅qi−pi−qi+2=ei⋅dip_i·q_i-p_i-q_i+2=e_i·d_ipi​⋅qi​−pi​−qi​+2=ei​⋅di​ ，就可以得出来两个东西 pi⋅qip_i·q_ipi​⋅qi​ 和 pi+qip_i+q_ipi​+qi​ 。\npi+qip_i+q_ipi​+qi​ 过程：\n\\begin{equation*}\n  \\begin{aligned}\n    p_i·q_i-p_i-q_i+2 &amp;= e_i·d_i \\\\\n        p_i+q_i &amp;= -(e_i·d_i-p_i·q_i+2) \\\\\n         &amp;= p_i·q_i-e_i·d_i-2 \\\\\n         &amp;= n_i-e_i·d_i-2\n  \\end{aligned}\n\\end{equation*}\n\n\n现在我们得知了 pi+qip_i+q_ipi​+qi​ 和 pi⋅qip_i·q_ipi​⋅qi​ ，怎么求出 pi,qip_i,q_ipi​,qi​ 呢？\n对，就是课本上的完全平方公式，因为 (pi+qi)2−(pi−qi)2=4pi⋅qi(p_i+q_i)^2-(p_i-q_i)^2=4p_i·q_i(pi​+qi​)2−(pi​−qi​)2=4pi​⋅qi​ 又知道了 pi+qip_i+q_ipi​+qi​ 和 pi⋅qip_i·q_ipi​⋅qi​ ，所以直接反向求出来 pi−qip_i-q_ipi​−qi​ ，就是一个和差问题，非常简单了。如下：\n为什么是 4pi⋅qi4p_i·q_i4pi​⋅qi​ ：\n\\begin{equation*}\n  \\begin{aligned}\n    (p_i+q_i)^2-(p_i-q_i)^2 &amp;= {p_i}^2+2p_i·q_i+{q_i}^2-({p_i}^2-2p_i·q_i+{q_i}^2) \\\\\n         &amp;= {p_i}^2+2p_i·q_i+{q_i}^2-{p_i}^2+2p_i·q_i-{q_i}^2 \\\\\n         &amp;= 4p_i·q_i\n  \\end{aligned}\n\\end{equation*}\n\npi−qip_i-q_ipi​−qi​ 过程：\n\\begin{equation*}\n  \\begin{aligned}\n    (p_i+q_i)^2-(p_i-q_i)^2 &amp;= 4p_i·q_i \\\\\n        (p_i+q_i)^2-4p_i·q_i &amp;= (p_i-q_i)^2 \\\\\n         (p_i-q_i)^2 &amp;= (p_i+q_i)^2-4p_i·q_i \\\\\n  \\end{aligned}\n\\end{equation*}\n\n注意，这里还要判断是否有解，如果这个东西的平方根不是整数或者是一个负数，就是无解的。（一个数的平方一定是非负数）\n\\begin{equation*}\n  \\begin{aligned}\n    p_i-q_i &amp;= \\sqrt{(p_i+q_i)^2-4p_i·q_i} \\\\\n         &amp;= \\sqrt{(p_i+q_i)^2-4n_i}\n  \\end{aligned}\n\\end{equation*}\n\n\\begin{equation*}\n  \\begin{aligned}\n    p_i &amp;= \\frac{p_i+q_i+(p_i-q_i)}{2} \\\\\n    q_i &amp;= p_i+q_i-p_i\n  \\end{aligned}\n\\end{equation*}\n\n\n这就解完了，代码先不贴了。\n","categories":["CSP/NOIP"],"tags":["OI","CSP-J/S"]},{"title":"Markdown入门","url":"/2022/08/06/get-started-with-markdown/","content":"这篇文章之后会与后面的内容重新整合排版，本文将会改成索引页。\n\n什么是Markdown?\n先放一段介绍：\n\nMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。——百度百科\n\nLet’s go!\n换行\nMarkdown不同于其他文本编辑器，Markdown一个换行实际为一个空格，Markdown只有两个及两个以上的换行符实际为一个换行。\n示例：\nthis is line 1this is line 2\n显示：\nthis is line 1 this is line 2\n示例：\nthis is line 1this is line 2\n显示：\nthis is line 1\nthis is line 2\n标题：\nMarkdown支持H1至H6的标题，分别在前面插入1~6个#符号即可。\n示例：\n# H1 标题## H2 标题### H3 标题#### H4 标题##### H5 标题###### H6 标题\n显示：\nH1 标题\nH2 标题\nH3 标题\nH4 标题\nH5 标题\nH6 标题\nps：请不要使用大量的H1或H2标题，否则会让文章显得不美观，还会给读者带来困扰。\n文字强调：\n一般粗体或斜体表示重要的内容。在Markdown语法中，我们可以用下划线_或星号*表示粗体或斜体。单下划线或星号表示斜体，双下划线或星号表示粗体，而三个星号或三个下划线表示加粗斜体。\n示例：\n*这是一个斜体*_这是一个斜体_**这是一个粗体**__这是一个粗体__***这是一个加粗斜体***___这是一个加粗斜体___\n显示：\n这是一个斜体\n这是一个斜体\n这是一个粗体\n这是一个粗体\n这是一个加粗斜体\n这是一个加粗斜体\n文本中我们经常要删除一段文本，使用~~删除线可以达到删除的效果。\n示例：\n~~要删除的一段文本~~\n显示：\n要删除的一段文本\n文章中经常会更改字体，更改颜色，由于markdown没有此功能，所以我们用html实现此功能。\n示例：\n&lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;华文彩云&lt;/font&gt;&lt;/font&gt;&lt;font color=red&gt;红色&lt;/font&gt;&lt;font color=#008000&gt;绿色&lt;/font&gt;&lt;font color=yellow&gt;黄色&lt;/font&gt;&lt;font color=Blue&gt;蓝色&lt;/font&gt;&lt;font color= #871F78&gt;紫色&lt;/font&gt;&lt;font color= #DCDCDC&gt;浅灰色&lt;/font&gt;\n实现：\n黑体\n微软雅黑\n华文彩云\n红色\n绿色\n黄色\n蓝色\n紫色\n浅灰色\n注意：某些Markdown编辑器不支持内嵌html功能，比如洛谷Markdown编辑器，所以在洛谷分站中采用图片代替！！！\n代码块：\n在使用blog时，我们有时需要插入一段代码，直接插入会让代码十分不美观，读者的体验也不好，所以我们要规范使用代码块。\n行内代码块：通过``行内代码块实现。\n示例：\n`include&lt;iostream&gt;`通常作为C++代码的第一行，`&lt;iostream&gt;`是输入输出流。\n显示：\n#include&lt;iostream&gt;通常作为C++代码的第一行，&lt;iostream&gt;是输入输出流。\n有时我们需要使用一大段代码，使用 ````即可。在第一个 ````后面加入你想要的语言即可。如cpp,pascal,python,markdown,latex等。注意，C++应为cpp！\n示例：\n```cpp\n#include&lt;iostream&gt;\n```\n显示：\n#include&lt;iostream&gt;\n有序列表与无序列表\n显而易见，用处无需多介绍。是用-、*或+表示。\n示例：\n- apple- orange- banana- grape+ apple+ orange+ banana+ grape* apple* orange* banana* grape\n均显示为：\n\napple\norange\nbanana\ngrape\n\n有序列表示例：\n1. one2. two3. three4. four或1. one1. two1. three1. four\n均显示为：\n\none\ntwo\nthree\nfour\n\n引用\nMarkdown中引用为&gt;符号。\n示例：\n&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用&gt;&gt;&gt;&gt;&gt; 五级引用&gt;&gt;&gt;&gt;&gt;&gt; 六级引用\n显示：\n\n一级引用\n\n二级引用\n\n三级引用\n\n四级引用\n\n五级引用\n\n六级引用\n\n\n\n\n\n\n链接与图片\n文章中，我们时不时要放一些链接，Markdown中以[链接标题](链接路径_http/https)使用链接。\n示例：\n[我的个人博客](https://myqf1234.github.io)\n显示：\n我的个人博客\n图片的语法与链接差不多，只是在前面加了个!，应为![图片下方文字](图片路径_http/https)\n示例：\n![Markdown-logo](https://assets.t3n.sc/news/wp-content/uploads/2013/07/markdown_vorschau.jpg)\n显示：\n\nMarkdown中还可以使用自动链接，在链接前后包上尖括号即可。\n示例：\n&lt;https://myqf1234.github.io&gt;\n显示：\nhttps://myqf1234.github.io\n图片链接：\n示例：\n[![Markdown-search](https://assets.t3n.sc/news/wp-content/uploads/2013/07/markdown_vorschau.jpg)](https://www.baidu.com/s?ie=utf-8&amp;wd=Markdown)\n显示：\n\n分割线\n分割线可以使用*或-，但是行内不能有其他的多余字符。\n示例：\n***   ***   *************************************************---   ---   -------------------------------------------------\n显示：\n\n\n\n\n转义字符\\\n在Markdown中，比如我们想使用*做装饰，而并非斜体，可以使用转义字符\\。\n示例：\n\\*A Text\\*\\~A Text\\~\n显示：\n*A Text*\n~A Text~\n更多功能\n敬请期待Markdown进阶篇！\n点个赞吧！\nBye!\n注：本文由自己的原创理解加上参考一些资料组成，如有不足、勘误或侵犯版权，请在评论区或联系我指正改进，谢谢！\n参考资料：\n\nhttps://www.luogu.com.cn/blog/luogu/how-to-use-markdown\nhttps://markdown.com.cn/\nhttps://www.bilibili.com/read/cv5975926/\n\n","categories":["教程"],"tags":["Markdown","教程"]},{"url":"/2025/08/08/sol-abc341-e/","content":"Solution：\n设设个序列为 SSS，如果有一个位置 iii 满足 Si=Si−1S_i=S_{i-1}Si​=Si−1​，那么把 iii 的位置记录下来（也就是说记录两个数相同的位置），由于数据范围是 5×1055 \\times 10^55×105 的，所以把位置可以用bool数组存下来，查询时如果 [l+1,r][l+1,r][l+1,r] 内没有被标记的位置，就是合法的，否则是不合法的，我们可以用线段树维护这个数组。\n对于修改，显然修改后区间内数的相对关系是不会改变的，修改区间外数的相对关系当然也不会改变，可能改变的只有 [l−1,l][l-1,l][l−1,l] 和 [r,r+1][r,r+1][r,r+1]，所以我们只需要从新判断这两个位置的数的关系是相同的还是不同的，并作出修改就好了。\n如何得知修改后每个数是 000 还是 111？我们可以维护一下每个数字被取反了几次，修改时区间加上 111，查询就是 (这个数被取反的次数mod  2+这个数原始的值)mod  2(这个数被取反的次数\\mod 2 + 这个数原始的值) \\mod 2(这个数被取反的次数mod2+这个数原始的值)mod2。区间加、单点查询用差分就可以维护。\n时间复杂度 O(Qlog⁡N)O(Q \\log N)O(QlogN)。\nCode:\n// By 0x0F#include&lt;bits/stdc++.h&gt;using namespace std;//#define int long longinline int read()&#123;\tint x=0,f=1;char ch=getchar();\twhile(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;\twhile(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-48;ch=getchar();&#125;\treturn x*f;&#125;struct Segtree&#123;\tstruct Node&#123;\t\tint l,r,val;\t&#125;tree[2000010];\tvoid pushup(int p)&#123;\t\ttree[p].val=tree[p&lt;&lt;1].val+tree[p&lt;&lt;1|1].val;\t&#125;\tvoid build(int p,int l,int r)&#123;\t\ttree[p].l=l,tree[p].r=r;\t\tif(l==r)return;\t\tint mid=l+r&gt;&gt;1;\t\tbuild(p&lt;&lt;1,l,mid);\t\tbuild(p&lt;&lt;1|1,mid+1,r);\t&#125;\tvoid modify(int p,int loc,int val)&#123;\t\tif(tree[p].l==tree[p].r)&#123;tree[p].val+=val;return;&#125;\t\tint mid=tree[p].l+tree[p].r&gt;&gt;1;\t\tif(loc&lt;=mid)modify(p&lt;&lt;1,loc,val);\t\telse modify(p&lt;&lt;1|1,loc,val);\t\tpushup(p);\t&#125;\tvoid equal(int p,int loc,int val)&#123;\t\tif(tree[p].l==tree[p].r)&#123;tree[p].val=val;return;&#125;\t\tint mid=tree[p].l+tree[p].r&gt;&gt;1;\t\tif(loc&lt;=mid)equal(p&lt;&lt;1,loc,val);\t\telse equal(p&lt;&lt;1|1,loc,val);\t\tpushup(p);\t&#125;\tint query(int p,int L,int R)&#123;\t\tif(L&lt;=tree[p].l&amp;&amp;tree[p].r&lt;=R)return tree[p].val;\t\tint mid=tree[p].l+tree[p].r&gt;&gt;1,ans=0;\t\tif(L&lt;=mid)ans+=query(p&lt;&lt;1,L,R);\t\tif(mid&lt;R)ans+=query(p&lt;&lt;1|1,L,R);\t\treturn ans;\t&#125;&#125;tree[2];char s[500010];int a[500010];int main()&#123;\tint n=read(),q=read();\tfor(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];\tfor(int i=1;i&lt;=n;i++)a[i]=s[i]-48;\ttree[1].build(1,0,n+10),tree[0].build(1,0,n+10);\tfor(int i=2;i&lt;=n;i++)if(a[i]==a[i-1])tree[1].equal(1,i,1);\tfor(int i=1;i&lt;=q;i++)&#123;\t\tint op=read(),l=read(),r=read();\t\tif(op==1)&#123;\t\t\ttree[0].modify(1,l,1),tree[0].modify(1,r+1,-1);\t\t\tint p1=(tree[0].query(1,0,l-1)%2+a[l-1])%2,\t\t\t\tp2=(tree[0].query(1,0,l)%2+a[l])%2,\t\t\t\tp3=(tree[0].query(1,0,r)%2+a[r])%2,\t\t\t\tp4=(tree[0].query(1,0,r+1)%2+a[r+1])%2;\t\t\tif(l&gt;1)&#123;\t\t\t\tif(p1!=p2)tree[1].equal(1,l,0);\t\t\t\telse tree[1].equal(1,l,1);\t\t\t&#125;\t\t\tif(r&lt;n)&#123;\t\t\t\tif(p3!=p4)tree[1].equal(1,r+1,0);\t\t\t\telse tree[1].equal(1,r+1,1);\t\t\t&#125;\t\t&#125;\t\telse&#123;\t\t\tif(l==r)puts(&quot;Yes&quot;);\t\t\telse if(tree[1].query(1,l+1,r))puts(&quot;No&quot;);\t\t\telse puts(&quot;Yes&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;"},{"url":"/2025/08/08/solution-P9460/","content":"题目中\n\n你需要求出有多少整数可能成为 bbb 的众数。\n\n想表达的意思应该是\n\n你需要求出有多少种数可能成为 bbb 的众数。\n\n吧。\n所以你输出的是能成为众数的种类数，而不是个数。\n解法：\n这里我提供一种贪心的做法。\n首先只需维护出每一种数出现的次数（因为题目只关心可能成为众数的数的数量）。\n接下来我们思考怎样一种数才可能成为众数。\n经过 kkk 次修改以后，一种数只有在被修改后出现次数大于等于被修改后出现次数最大的那种数的出现次数时才可以成为众数。\n那么每一次修改是什么呢？\n想要让第 iii 种数成为众数，对于每一次修改，我们将除了第 iii 种数外的一个数修改为第 iii 种数。这样就让第 iii 种数出现的次数 +1+1+1 ，让除了第 iii 种数外的一种数出现的次数 −1-1−1 。不难想到，这样可以让第 iii 种数出现的次数最大。\n具体来说，设第 iii 种数出现的次数为 viv_ivi​ ，那么它在被操作 kkk 次后出现的次数为 vi+kv_i+kvi​+k ，设经过操作后的最大出现次数为 xxx ，那么第 iii 种数能成为众数的条件是：\nvi+k≥xv_i+k \\geq x\nvi​+k≥x\n因为 vi+kv_i+kvi​+k 已经确定了，所以想让成为众数的数尽可能多，就要让 xxx 最小。\n怎么让 xxx 最小呢？\n我们让当前一个最大的出现次数 −1-1−1 ，然后把它放回原数列，再找到当前一个最大的出现次数，如此操作 kkk 次就可以了。\n比如一个数组 v=[1,2,3,5,4,3]v=[1,2,3,5,4,3]v=[1,2,3,5,4,3] ，经过 555 次操作后的状态如下：\n第一次操作：\n[1,2,3,4,4,3][1,2,3,4,4,3]\n[1,2,3,4,4,3]\n第二次操作：\n[1,2,3,3,4,3][1,2,3,3,4,3]\n[1,2,3,3,4,3]\n第三次操作：\n[1,2,3,3,3,3][1,2,3,3,3,3]\n[1,2,3,3,3,3]\n第四次操作：\n[1,2,2,3,3,3][1,2,2,3,3,3]\n[1,2,2,3,3,3]\n第五次操作：\n[1,2,2,2,3,3][1,2,2,2,3,3]\n[1,2,2,2,3,3]\n由于每次都要取出其中的最大值，所以这个问题刚好可以用大根堆（优先队列）来解决。每次操作取出堆顶，将其 −1-1−1 ，然后丢回堆里面。\n核心代码如下：\npriority_queue&lt;int&gt;q;for(int i=1;i&lt;=tot;i++)&#123;\tq.push(v[i]);&#125;while(k--)&#123;\tint tmp=q.top()-1;\tq.pop();\tq.push(tmp);&#125;tmp=q.top();\n由于堆每次操作的复杂度为 O(log⁡n)O(\\log n)O(logn) ，kkk 次操作的复杂度就是 O(klog⁡n)O(k \\log n)O(klogn) ，也就是 O(nlog⁡n)O(n \\log n)O(nlogn) ，在 10610^6106 的数据下可以通过。\n最后一个问题，怎么处理无限多种数可以成为众数的情况？\n如果经过操作后的最大出现次数 x≤kx \\leq kx≤k 时，也就是说任意一个数操作 kkk 次都能修改成众数，自然答案就是无限了。\n代码如下（写的不太好）：\n#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int cnt[1919810],v[1919810];priority_queue&lt;int&gt;q;int n,k,tot;signed main()&#123;\tcin&gt;&gt;n&gt;&gt;k;\tint vk=k;\tfor(int i=1;i&lt;=n;i++)&#123;\t\tint x;\t\tcin&gt;&gt;x;\t\tcnt[x]++;\t&#125;\tfor(int i=1;i&lt;=n;i++)&#123;\t\tif(cnt[i])v[++tot]=cnt[i];\t&#125;\tfor(int i=1;i&lt;=tot;i++)&#123;\t\tq.push(v[i]);\t&#125;\tint mx=q.top();\twhile(k--)&#123;\t\tint x=q.top()-1;\t\tq.pop();\t\tq.push(x);\t&#125;\tint ww=q.top(),ans=0;\tif(ww&lt;=vk)&#123;\t    cout&lt;&lt;&quot;pigstd&quot;&lt;&lt;endl;\t    return 0;\t&#125;\tfor(int i=1;i&lt;=tot;i++)&#123;\t\tif(v[i]+vk&gt;=ww)&#123;\t\t\tans++;\t\t&#125;\t&#125;\tcout&lt;&lt;ans&lt;&lt;endl;\treturn 0;&#125;"},{"title":"线段树入门","url":"/2022/08/16/segtree-start/","content":"蒟蒻刚学完线段树不久，写一篇线段树入门笔记。\n线段树是一种二叉搜索树，是 OIOIOI 中很重要的数据结构。其支持单点修改，区间修改，单点查询，区间查询（最大最小值、求和）等操作。虽然比树状数组慢，但是它支持的操作更多。\n\n线段树可以高效地解决具有区间性质的问题，例如区间求和，一次操作(修改，查询)就要遍历整个数组，单次操作时间复杂度 O(n)O(n)O(n) ，qqq 次修改复杂度 O(nq)O(nq)O(nq) ，远远超时。而线段树单次修改时间复杂度 O(log⁡n)O(\\log n)O(logn) ， qqq 次修改复杂度 O(qlog⁡n)O(q \\log n)O(qlogn) ，节约的不少时间。\n线段树基本结构\n比如一个长度为 555 的集合 {8,3,11,4,13}\\{8,3,11,4,13\\}{8,3,11,4,13} ，要维护他它的区间总和，建造出的线段树如下图所示：\n\n如图所示，线段树的性质如下：\n\n\n1.1.1. 线段树的每一个节点都管理着一段区间，其值为这一区间内需要维护的值，根节点（编号为 111 ）管理着整段区间 [1,n][1,n][1,n] ，叶子节点管理的区间长度为 111 。\n\n\n2.2.2. 除叶子节点外，其他节点分别有两个子节点，如当前节点的编号为 ppp ,则左子节点的编号为 2p2p2p ，右子节点的编号为 2p+12p+12p+1 。\n\n\n3.3.3. 如节点 ppp 的管理区间为 [l,r][l,r][l,r] ，设此区间的中点为 midmidmid ，则左子节点管理区间的范围是 [l,mid][l,mid][l,mid] ，右子节点管理区间的范围是 [mid+1,r][mid+1,r][mid+1,r] 。\n\n\n线段树建树\n这里以维护区间总和为例子。\n我们考虑每个节点需要储存的信息有：当前节点管理区间的左右端点，维护的值，以及标记等(后面会讲到)，我们可以用一个结构体存储。\n代码：\nstruct Node&#123;    int l,r; //左右端点    long long sum; //维护总和&#125;tree[4*n];\n线段树空间一定要开原数组的4倍，不然很有可能爆空间。\n\n因为树具有天然的递归性质，所以我们可以用递归建树。如果当前节点是叶子节点，那么将其赋值为当前区间的值，否则递归build一下左子树，再build一下右子树，最后回传一下左右子节点的 sumsumsum 就可以了。\n代码：\n//p为当前节点编号，l为当前区间起点，r为当前区间终点void build(int p,int l,int r)&#123;    tree[p].l=l,tree[p].r=r; //当前树的管理区间范围    if(l==r)&#123;        tree[p].sum=a[l]; //叶子节点直接赋值        return;    &#125;    int mid=(l+r)/2; //区间中点    build(p*2,l,mid); //递归建左子树    build(p*2+1,mid+1,r); //递归建右子树    pushup(p); //回传sum&#125;\n回传pushup的时候，对于区间性质的问题来说，就是将左右两个节点的答案合并就可以了。\n示例图：\n\n区间求和公式如下：\nsump=sum2p+sum2p+1sum_{p}=sum_{2p}+sum_{2p+1}\nsump​=sum2p​+sum2p+1​\n区间最大/最小值公式如下：\nsump=max⁡(sum2p,sum2p+1)sum_{p}=\\max(sum_{2p},sum_{2p+1})\nsump​=max(sum2p​,sum2p+1​)\n代码：\n//p为当前节点编号void pushup(int p)&#123;    tree[p].sum=tree[p*2].sum+tree[p*2+1].sum;&#125;\n建树时间复杂度可以估计为 O(n)O(n)O(n) ，因为需要遍历所有的节点。\n\n线段树单点修改\n比如要将axa_xax​ 的数值修改，就是将线段树中区间起点为 xxx 且长度为 111 的节点修改，然后再回传回根节点，那么整体的思路如下：\n\n\n1.1.1. 从根节点出发，往下寻找目标节点，修改其值。\n\n\n2.2.2. 将总和回传到根节点。\n\n\n举个例子，还是之前的集合 {8,3,11,4,13}\\{8,3,11,4,13\\}{8,3,11,4,13} ，现要将第 222 个数 333 加上 666 ，操作如下图所示：\n\n\n我们可以考虑使用递归实现。如果是目标节点，那么修改，然后return，否则递归向下，目标在左边就遍历左子树，目标在右边就遍历右子树，最后回传总和就可以了。\n代码：\n//p为当前节点编号，x为要修改的位置，k为要加上的值void update(int p,int x,int k)&#123;    if(tree[p].l==tree[p].r)&#123; //要修改的节点        tree[p].sum+=k; //直接修改，返回        return;    &#125;    int mid=(tree[p].l+tree[p].r)/2;    if(x&lt;=mid)update(p*2,x,k); //在左子树，递归到左边    if(x&gt;mid)update(p*2+1,x,k); //在右子树，递归到右边    pushup(p); //回传sum&#125;\n单点修改的时间复杂度为 O(log⁡n)O(\\log n)O(logn) ，因为向下递归到叶子节点是遍历树的深度。\n\n线段树区间查询\n单点查询没什么可说的吧，和单点修改类似，我们主要看一下区间查询。\n区间查询分为三种情况：\n\n1.1.1. 当前节点的区间包含在查询区间之内，直接返回当前节点的 sumsumsum 值。\n2.2.2. 当前区间与左子树区间有重叠部分，那么递归搜索左子树，加上答案。\n3.3.3. 当前区间右子树区间有重叠部分，那么递归搜索右子树，加上答案。\n\n还是之前那个例子，比如查询区间 [2,4][2,4][2,4] ，如下图所示：\n\n\n一般来说查询要加long long，因为所有数的总和有可能爆int。\n\n代码：\n//p为当前节点编号，l为查询区间的左端点，r为查询区间的右端点long long query(int p,int l,int r)&#123;    if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r)&#123; //在查询区间内        return tree[p].sum; //直接返回值    &#125;    long long ans=0;    int mid=(tree[p].l+tree[p].r)/2;    if(l&lt;=mid)ans+=query(p*2,l,r); //如果左子树区间有重叠部分，答案加上左边的查询    if(r&gt;mid)ans+=query(p*2+1,l,r); ////如果右子树区间有重叠部分，答案加上右边的查询    return ans;&#125;\n区间的时间复杂度为 O(log⁡n)O(\\log n)O(logn) ，因为每次查询都要将线段树一分为二，最后会分成 log⁡n\\log nlogn 个部分。\n\nP3374 【模板】树状数组 1\n虽然此题的题目看起来和线段树毫不相干，但是这可以用线段树去做。\n这是一个线段树单点修改，区间查询的模板题。\n\n代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123;    int l,r; //左右端点    long long sum; //维护总和&#125;tree[4*500010];int n,m,a[500010];inline int read()&#123;    int x=0,f=1;char ch=getchar();    while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;        if(ch==&#x27;-&#x27;)f=-1;ch=getchar();    &#125;    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;        x=x*10+ch-48;ch=getchar();    &#125;    return x*f;&#125;void pushup(int p)&#123;    tree[p].sum=tree[p*2].sum+tree[p*2+1].sum;&#125;void build(int p,int l,int r)&#123;    tree[p].l=l,tree[p].r=r; //当前树的管理区间范围    if(l==r)&#123;        tree[p].sum=a[l]; //叶子节点直接赋值        return;    &#125;    int mid=(l+r)/2; //区间中点    build(p*2,l,mid); //递归建左子树    build(p*2+1,mid+1,r); //递归建右子树    pushup(p); //回传sum&#125;void update(int p,int x,int k)&#123;    if(tree[p].l==tree[p].r)&#123; //要修改的节点        tree[p].sum+=k; //直接修改，返回        return;    &#125;    int mid=(tree[p].l+tree[p].r)/2;    if(x&lt;=mid)update(p*2,x,k); //在左子树，递归到左边    if(x&gt;mid)update(p*2+1,x,k); //在右子树，递归到右边    pushup(p); //回传sum&#125;long long query(int p,int l,int r)&#123;    if(tree[p].l&gt;=l&amp;&amp;tree[p].r&lt;=r)&#123; //在查询区间内        return tree[p].sum; //直接返回值    &#125;    long long ans=0;    int mid=(tree[p].l+tree[p].r)/2;    if(l&lt;=mid)ans+=query(p*2,l,r); //如果左子树区间有重叠部分，答案加上左边的查询    if(r&gt;mid)ans+=query(p*2+1,l,r); ////如果右子树区间有重叠部分，答案加上右边的查询    return ans;&#125;int main()&#123;    n=read(),m=read();    for(int i=1;i&lt;=n;i++)&#123;        a[i]=read();    &#125;    build(1,1,n); //从根节点出发，建造 [1,n] 区间的线段树    while(m--)&#123;        int op,x,y;        op=read(),x=read(),y=read();        if(op==1)&#123;            update(1,x,y); //从根节点出发，区间 [x,x] 的值 +y        &#125;        else&#123;            long long ans=0;            printf(&quot;%lld\\n&quot;,query(1,x,y)); //从根节点出发，查询区间 [x,y] 的总和        &#125;    &#125;    return 0;&#125;\n因为需要操作 mmm 次，所以整体时间复杂度为 O(mlog⁡n)O(m \\log n)O(mlogn) 。\n\n线段树区间修改\n要把线段树的一段区间修改为某个值，最简单、最暴力的方法是遍历每一个节点暴力单点修改。\n但是这种方法的时间复杂度是炸的，单次暴力区间修改时间复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) ，qqq 次修改时间复杂度 O(q⋅nlog⁡n)O(q·n \\log n)O(q⋅nlogn) ，甚至比直接暴力循环修改的时间复杂度还多一个 log⁡\\loglog 。\n为什么这样子复杂度这么高呢？我们可以画个图。集合 {8,3,11,4,13}\\{8,3,11,4,13\\}{8,3,11,4,13} ，区间 [1,3][1,3][1,3] 统一加 555 ，要修改到的节点如下图所示：\n\n总之可以看到，画绿线的节点都是修改区间下的子节点，其实完全没有逐一修改的必要。我们可以先让区间节点修改了，再加上一个“懒”标记，查询时再下传到子节点里面，这样可以大幅提升效率。\n“懒”标记指的是当前节点修改过了，但没有让下边的节点修改的一种标记，可以再查询时需要时下传，大大节省时间，所以是懒标记。\n\n最后\n好了，就暂时先写到这里吧，因为这个蒟蒻要卷whk干其他事，就先咕咕了。\n已知错误：\n由于这个蒟蒻的知识短浅疏忽，误将树形视图的方括号写成了圆括号，因为太多改不过来了。\n\n请各位大佬帮忙指出文章的问题，以免误人子弟。\n","categories":["OI记"],"tags":["OI","数据结构"]},{"title":"AT3935题解","url":"/2022/07/13/solution-at3935/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n回文数判断前面几位大佬已经讲的很清楚了，我讲一种新的 STL 做法。\n\n这里介绍两个函数，reverse()和to_string()。\nto_string()函数\nto_string()是在 C++11 中新加入的函数，定义于&lt;string&gt;头文件中。用法为to_string(val)，其中val可以是int,long,long long,unsigned int,unsigned long long,fload,double,long double类型。其作用是将数字转换成字符串。\nreverse()函数\nreverse()函数是一个可以翻转数组，string，vector等数据结构的函数，定义于&lt;algorithm&gt;头文件中。用法为reverse(p1,p2)，p1为前指针，p2为后指针。\nreverse(array,array+a_length) //数组reverse(str.begin(),str.end()) //stringreverse(v.begin(),v.end()) //vector\n明白之后代码就简单多了。\nCode：\n#include&lt;bits/stdc++.h&gt;using namespace std;int cnt=0;int main()&#123;\tint l,r;\tcin&gt;&gt;l&gt;&gt;r;\tfor(int i=l;i&lt;=r;i++)&#123;\t\tstring s=to_string(i);\t\tstring ts=s;\t\treverse(s.begin(),s.end());\t\tif(ts==s)&#123;\t\t\tcnt++;\t\t&#125;\t&#125;\tcout&lt;&lt;cnt&lt;&lt;endl;\treturn 0;&#125;\n","categories":["洛谷题解"]},{"url":"/2025/08/08/solution-P9459/","content":"解法\n语法题。\n由于string每次用cin读入会自动屏蔽掉空格，所以我们只需要定义四个string型变量 a,b,c,da,b,c,da,b,c,d 。对于判断，首字母用s[i]==0，而整个字符串可以用string的性质，直接用s==&quot;ding&quot;就可以了。\n注意，一个字符用单引号''括起来，字符串用双引号&quot;&quot;括起来。\n代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\tint n;\tcin&gt;&gt;n;\twhile(n--)&#123;\t\tstring a,b,c,d;\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; //读入四个字符串\t\tif(a[0]==&#x27;y&#x27;&amp;&amp;b[0]==&#x27;y&#x27;&amp;&amp;c==&quot;ding&quot;&amp;&amp;d==&quot;zhen&quot;)&#123; //判断是否符合要求\t\t\tcout&lt;&lt;&quot;Yes\\n&quot;;\t\t&#125;\t\telse cout&lt;&lt;&quot;No\\n&quot;;\t&#125;\treturn 0;&#125;"},{"url":"/2025/08/08/solution-abc319d/","content":"本题考虑使用二分答案。\n思路\n关于本题单调性的证明：因为显示器的宽度越大，一行能显示的宽度越多，所以显示需要的行数越少（单词总量不变）。所以显示器的宽度和显示需要的行数具有单调递减的关系，所以可以使用二分。\n二分枚举显示器的宽度 www，然后计算以 www 为宽度显示单词需要的最少行数，如果需要的行数小于等于 mmm，则符合要求，否则不符合要求。\n怎么计算呢？\n如果显示器的宽度 www 小于单词的最大宽度 mwmwmw，说明一个单词都无法放进显示器中，显然是不符合要求的。\n令 sumsumsum 表示当前行已经用了多少宽度，cntcntcnt 表示当前用了多少行，一次枚举单词的长度 lil_ili​，如果当前宽度加上一个空格和 lil_ili​ 的长度大于 www，说明当前行已经放不下这个单词了，需要新开一行，让 cntcntcnt 加 111，并且让 sumsumsum 等于 lil_ili​，否则 sumsumsum 加上 lil_ili​ 和一个空格的长度。\n时间复杂度：二分的复杂度是 O(log⁡n)O(\\log n)O(logn)，计算一遍的复杂度是 O(n)O(n)O(n)，整体时间复杂度 O(nlog⁡n)O(n \\log n)O(nlogn)。\n代码\n#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int l[1000010],n,m,p,mw;bool check(int w)&#123;    if(w&lt;mw)return 0;\tint cnt=1,sum=0;\tsum=l[1];\tfor(int i=2;i&lt;=n;i++)&#123;\t\tif(sum+l[i]+1&gt;w)sum=l[i],cnt++;\t\telse sum+=l[i]+1;\t&#125;\treturn cnt&lt;=m;&#125;signed main()&#123;\tcin&gt;&gt;n&gt;&gt;m;\tfor(int i=1;i&lt;=n;i++)cin&gt;&gt;l[i],mw=max(mw,l[i]);\tfor(int i=(1LL&lt;&lt;62);i;i&gt;&gt;=1)if(!check(p+i))p+=i;\tcout&lt;&lt;p+1LL&lt;&lt;endl;\treturn 0;&#125;"},{"title":"CF1591A题解","url":"/2021/12/27/solution-cf1591a/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n这题真还挺简单的(红题不都是吗？)\n\n废话不多说！开始！(这也不废话吗)\n理解题意\n题目描述\n题中说得很清楚了\n输入格式\n本题有多组数据。首先，输入整数 ttt ，表示数据组数 t(1≤t≤100)t(1\\le t\\le100)t(1≤t≤100) ，对于每组数据，输入整数 nnn ,表示一共浇花或没浇花的天数 (1≤n≤100)(1\\leq n\\leq100)(1≤n≤100) ，然后输入 nnn 个整数 a1,a2,…an (ai=0a_1,a_2,\\dots a_n\\ (a_i=0a1​,a2​,…an​ (ai​=0 或 ai=1)a_i=1)ai​=1) ， ai=1a_i=1ai​=1 表示第 iii 天浇花了，否则表示第 iii 天没浇花。\n输出格式\n对于每组数据，如果花活着，输出花 nnn 天后的高度，如果花死了，输出 −1-1−1 。\n解法\n这道题我们用模拟的解法。用一变量 hhh 表示花的高度, a1,a2,…ana_1,a_2,\\dots a_na1​,a2​,…an​ 浇表示第几天浇花了没。一开始让 hhh 为 111 ，从第 111 天起每天都会有四种情况：\n\n如果今天浇花而且昨天也浇花了， h+5h+5h+5 。\n如果今天浇花而且昨天没浇花， h+1h+1h+1 。\n如果今天没浇花而且昨天浇花了， hhh 不变。\n如果今天没浇花而且昨天也没浇花，花就死掉了，无需继续判断，直接输出 −1-1−1 。\n\n但是，这样有一个漏洞：如果第一天没浇花，程序会认为第 111 天和第 000 天(初始状态)都没浇花，然而误判为花死掉了，显然，我们哪怕凭生活经验来看，这都是不可能的，更别说本题了。怎么办？特判。当 i=1i=1i=1 时忽略掉上面的第一、第三、第四条，就可以了。\n我们看一组数据：\nSimple Input431 0 130 1 141 0 0 110\n四组数据，一组一组看。\n\n\n一共三天，第一天浇花了，高度+1，第三天浇花了,高度+1，三天后高度为1+1+1=3；\n\n\n一共三天，第二天浇花了，高度+1，第三天浇花了，且第二天浇花了,高度+5，三天后高度为1+1+5=7；\n\n\n共有四天，第一天浇花了，高度+1，但第二、三天都没浇花，花死掉了，输出-1，结束；\n\n\n共有一天，这天没浇花，高度不变，一天后高度为1.\n\n\n所以，输出应该是：\nSimple Output37-11\n核心CODE：：\nint n;cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)&#123;\tcin&gt;&gt;a[i];         //输入 &#125;for(int i=1;i&lt;=n;i++)&#123;\tif(i==1)&#123;\t\tif(a[i]==1)&#123;\t\t\th++;\t\t&#125;\t\tcontinue;\t&#125;\tif(a[i]==1&amp;&amp;a[i-1]==1)&#123;\t\th+=5;\t&#125;\telse if(a[i-1]==1&amp;&amp;a[i]==0)&#123;\t\t\t&#125;\telse if(a[i-1]==1&amp;&amp;a[i]==0)&#123;\t\th++;\t&#125;\telse&#123;\t\tcout&lt;&lt;-1&lt;&lt;endl;\t\tbreak;\t&#125;&#125;\n","categories":["洛谷题解"]},{"url":"/2025/08/08/solution-cf1738f/","content":"Solution:\n本题是比较有意思的，我讲一种较好理解的证明方法。\n对于每一个染色的连通块的点集 SSS，需要满足以下条件：\n∑u:Sdeg(u)≤nS2\\sum_{u:S}deg(u) \\leq n_S^2\nu:S∑​deg(u)≤nS2​\n对于每一个操作，我们寻找度数最大的没有被染色的点 uuu，依次询问 uuu 的临边，如果 uuu 的相邻点 vvv 被染色了，那么把 uuu 和 vvv 染成同一种颜色，否则把 uuu 和其所有临边染成一种新的颜色。\n这种贪心的策略需要证明两种问题：\n\n总的询问次数 ≤n\\leq n≤n；\n需要满足的上述条件。\n\n·\t 对于每次询问的度数 deg(i)deg(i)deg(i) ，\nCode:\n// By 0x0F#include &lt;bits/stdc++.h&gt;using namespace std;//#define int long longinline int read() &#123;    int x = 0, f = 1; char ch = getchar();    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;if (ch == &#x27;-&#x27;) f = -1; ch = getchar();&#125;    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;x = x * 10 + ch - 48; ch = getchar();&#125;    return x * f;&#125;int deg[1010], col[1010], tot;void solve() &#123;    int n = read();    for (int i = 1; i &lt;= n; i++) deg[i] = read();    while (1) &#123;        int maxd = 0, ind = 0;        for (int i = 1; i &lt;= n; i++)            if (deg[i] &gt;= maxd &amp;&amp; !col[i]) maxd = deg[i], ind = i;        if (ind == 0) &#123;            printf(&quot;! &quot;);            for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, col[i]);            printf(&quot;\\n&quot;); fflush(stdout);            for (int i = 1; i &lt;= n; i++) col[i] = 0;            tot = 0;            break;        &#125;        vector&lt;int&gt; vec; int cl = 0;        vec.push_back(ind);        for (int i = 1; i &lt;= deg[ind]; i++) &#123;            printf(&quot;? %d\\n&quot;, ind); fflush(stdout);            int j = read(); vec.push_back(j);            if (col[j] &amp;&amp; !cl) &#123;cl = col[j]; break;&#125;        &#125;        if (!cl) cl = ++tot;        for (int i:vec) col[i] = cl;    &#125;&#125;int main() &#123;    int t = read();    while (t--) solve();    return 0;&#125;"},{"title":"CF620A题解","url":"/2022/07/20/solution-cf620a/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\nupdate：有一个图挂了，我重新补上，管理求过\n\n这道题不难，主要考察的是数学知识。\n前铺：欧几里得距离\n首先我们都知道，两点之间线段最短，如下图所示：\n\n这个距离很好求，我们把 AAA 点和 BBB 所在的轴画出来，如下图所示：\n\n很容易看出来这三条线构成了一个直角三角形。根据勾股定理，我们就求出了距离公式，如下：\ndis(i,j)=(xi−xj)2+(yi−yj)2\\large{dis(i,j) = \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}}\ndis(i,j)=(xi​−xj​)2+(yi​−yj​)2​\n这个距离公式也是现在最常用的距离公式。\n切比雪夫距离\n切比雪夫距离用于解决格点上的距离问题。这类问题只能向自己点的上、下、左、右、左上、左下、右上、右下方向走。\n在这个问题中，每走一个斜线和走一个直线的距离相同。那我们想要距离最短，那就按照欧几里得距离的思想，尽量先走斜线到对方的横坐标上，在走直线到达对方的点，如下图所示：\n\n这就是当前问题下的最短距离。\n那么怎么算出距离呢？\n因为棋盘的性质，走一个斜线等于走一个直线的距离，所以只需要求出两边距离的最大值就可以了。公式如下：\ndis(i,j)=max⁡(∣xi−xj∣,∣yi−yj∣)\\large{dis(i,j)=\\max(|x_i-x_j|,|y_i-y_j|)}\ndis(i,j)=max(∣xi​−xj​∣,∣yi​−yj​∣)\n按照本题的题意，此题为切比雪夫距离。\n","categories":["洛谷题解"]},{"title":"CF926C题解","url":"/2022/07/21/solution-cf926c/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n这是一道很简单的模拟。\n\n解题思路：\n我们定义两个变量 cnt1cnt1cnt1 cnt2cnt2cnt2，分别用于记录上一个连续 0/10/10/1 区间的长度和这一个连续 0/10/10/1 区间的长度。只要这个连续区间的长度不等于上个区间的长度，那么直接输出NO，然后return 0就可以了(因为这里不一样后面就无需判断，这是一个小优化)。如果相等，那么 cnt2cnt2cnt2 清零，重新计算新的连续区间的长度，以此类推计算就可以了。\n那么这个过程怎么实现呢？\n对于代码实现来说，对于当前的 aia_iai​ 来说，分两种情况：\n\n\n如果 aia_iai​ 等于 ai−1a_{i-1}ai−1​ ，那么说明还在当前的区间中，那么 cnt2+1cnt2+1cnt2+1 ，长度加 111 。\n\n\n如果 aia_iai​ 不等于 ai−1a_{i-1}ai−1​ ，那么按照上面的思路判断就可以了。\n\n\n这里需要注意一些细节：加一个特判，判断 cnt1cnt1cnt1 是不是 000 ，并在cnt2=1前面把 cnt1cnt1cnt1 修改为 cnt2cnt2cnt2 ，就可以了。然后把 an+1a_{n+1}an+1​ 赋值为 222 ，循环到 n+1n+1n+1 就可以处理最后一次的问题。\nps：一定要从 222 开始循环，要不然会出问题，为什么呢？\n因为从 111 开始循环，那么 a0a_0a0​ 的值始终是 000 ，我们无法确定 a1a_1a1​ 是零是一，这样就会造成 cntcntcnt 错误。\n如果大家还是看的不清楚，可以看代码里的注释。\nCode:\na[n+1]=2;for(int i=1;i&lt;=n;i++)&#123;\tcin&gt;&gt;a[i];&#125;for(int i=2;i&lt;=n+1;i++)&#123;\tif(a[i]==a[i-1])&#123;  //如果和上一个数字相同\t\tcnt2++; //说明这个区间还没有结束，长度++\t&#125;\telse&#123; //不相同\t\tif(cnt2!=cnt1&amp;&amp;cnt1)&#123;   //与上次长度不相同且不是第一次计数\t\t\tcout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;   //NO\t\t\treturn 0;\t\t&#125;\t\tcnt1=cnt2;    //长度赋值，防止出现第一次cnt1=0的情况\t\tcnt2=1;   //长度清空为1，因为这是新区间的第一个数\t&#125;&#125;\tcout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;\n这个写法应该是目前特判比较少的解法了吧。\n","categories":["洛谷题解"]},{"url":"/2025/08/08/solution-p9496/","content":"按位与和按位或\n按位与 (&amp;\\And&amp;) 是指在二进制下对两个数的每个数位分别进行与运算，例如：\n5&amp;7=(101)2&amp;(111)2=(101)2=55 \\And 7 = (101)_2 \\And (111)_2 = (101)_2 =5\n5&amp;7=(101)2​&amp;(111)2​=(101)2​=5\n按位或 (∣|∣) 是指在二进制下对两个数的每个数位分别进行或运算，例如：\n5 ∣ 6=(101)2 ∣ (110)2=(111)2=75 \\ | \\ 6 = (101)_2 \\ | \\ (110)_2 = (111)_2 =7\n5 ∣ 6=(101)2​ ∣ (110)2​=(111)2​=7\n注意：按位与（C++ 中为&amp;）逻辑与（C++ 中为&amp;&amp;）、按位或（C++ 中为|）逻辑或（C++ 中为||）不同，请注意区别。\n思路\n这个题分三种情况。如果 m=nm=nm=n ，显然要操作的次数为 000 ，如果 n ∣ m=mn\\ |\\ m=mn ∣ m=m 或 n&amp;m=mn \\And m=mn&amp;m=m ，那么要操作的次数为 111 ，否则要操作的次数为 222 。\n为什么这样正确呢？\n对于任意两个 nnn 和 mmm ，可以这么理解：先将 n&amp;0n \\And 0n&amp;0 ，然后将 n ∣ mn \\ | \\ mn ∣ m 就可以得到 mmm ，最多只需要两步。\n还有一种特殊情况，就是 nnn 中有的 111 ， mmm 中没有，或 mmm 中有的 111 ， nnn 中没有，其他部分完全相同时只需要 &amp;\\And&amp; 或 ∣ m| \\ m∣ m 就可以了，例如：\nn&amp;m=(1010101010101)2&amp;(1010001010001)2=(1010001010001)2n \\And m = (1010101010101)_2 \\And (1010001010001)_2 = (1010001010001)_2\nn&amp;m=(1010101010101)2​&amp;(1010001010001)2​=(1010001010001)2​\nn ∣ m=(1010001010001)2 ∣ (1010101010101)2=(1010101010101)2n \\ | \\ m = (1010001010001)_2 \\ | \\ (1010101010101)_2 = (1010101010101)_2\nn ∣ m=(1010001010001)2​ ∣ (1010101010101)2​=(1010101010101)2​\n这样只需要一步就可以解决。\n代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\tint t;\tcin&gt;&gt;t;\twhile(t--)&#123;\t\tlong long n,m;\t\tcin&gt;&gt;n&gt;&gt;m;\t\tif(n==m)&#123;\t\t\tcout&lt;&lt;0&lt;&lt;endl;continue;\t\t&#125;\t\tif((n|m)==m||(n&amp;m)==m)cout&lt;&lt;1&lt;&lt;endl;\t\telse cout&lt;&lt;2&lt;&lt;endl;\t&#125;\treturn 0;&#125;"},{"title":"题解 P3059 [USACO12NOV] Concurrently Balanced Strings G","url":"/2024/08/13/solution-p3059/","content":"思路\n一种 vector&lt;int&gt;, vector&lt;int&gt; 的 map 做法，代码稍长一些但是特别好想。\n先考虑 k=1k = 1k=1 时的做法，后面 kkk 增大时在原基础上改动一点就可以了。\n看到左右括号，我们容易想到遇到左括号加 111，右括号减 111，记第到 iii 个位置的前缀和为 sumisum_isumi​。显然，区间 [l,r][l,r][l,r] 若是合法的，必须满足以下条件：\n\n左括号和右括号的数量相等。\n在任何位置，前面的右括号个数不能超过左括号。\n\n用数学的形式表达，就是：\n\nsumr−suml−1=0sum_r - sum_{l-1} = 0sumr​−suml−1​=0。\n对于 [l,r][l, r][l,r] 之间的任意一点 iii，满足 sumi−suml−1≥0sum_i - sum_{l - 1} \\geq 0sumi​−suml−1​≥0。\n\n移项，得：\n\nsumr=suml−1sum_r = sum_{l-1}sumr​=suml−1​。\n对于 [l,r][l, r][l,r] 之间的任意一点 iii，满足 sumi≥suml−1sum_i \\geq sum_{l - 1}sumi​≥suml−1​。\n\n我们分开考虑每个条件。\n若假设 lll 为当前计算区间的左端点，那么若存在一点 iii 满足 sumi&lt;suml−1sum_i &lt; sum_{l - 1}sumi​&lt;suml−1​ 且 i≥li \\geq li≥l，那么 iii 以及后面的所有点和 lll 所构成的区间都是不合法的。那么我们找到 lll 右边第一个比 suml−1sum_{l - 1}suml−1​ 小的位置 RRR（可以用单调栈预处理），那么 RRR 以前的位置都可能合法。条件二的限制就解决了。结合条件一，我们预处理每个 sumsumsum 值都出现过的坐标，用 vector 存起来排序，在 suml−1sum_{l - 1}suml−1​ 查找 [i,R−1][i, R - 1][i,R−1] 之间有几个坐标，加到答案即可。\n对于增加的 kkk，RRR 取 kkk 个数里的最小值，由于 k≤10k \\leq 10k≤10，我们直接把 kkk 个 sumsumsum 放到一个 vector 里并做成 map，每次用 vector 查就好了，自己想想就清楚了。\n时间复杂度 O(nklog⁡n)O(nk \\log n)O(nklogn)。\n代码\n// By 0x0F#include &lt;bits/stdc++.h&gt;// #define AT_contest#ifdef AT_contest#include &lt;atcoder/all&gt;using namespace atcoder;#endifusing namespace std;// #define int long long#define fi first#define se second#define pb push_back#define sz(x) (x).size()#define all(x) (x).begin(), (x).end()#define pii pair&lt;int, int&gt;#define mpii map&lt;int, int&gt;#define vi vector&lt;int&gt;#define fr front#define bk back#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)inline int read() &#123;    int x = 0, f = 1; char ch = getchar();    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;if (ch == &#x27;-&#x27;) f = -1; ch = getchar();&#125;    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;x = x * 10 + ch - 48; ch = getchar();&#125;    return x * f;&#125;#define inf 0x7fffffff#define INF 0x3f3f3f3f3f3f3f3fll#if defined(int)#define RETURN_MAIN signed#endif#if !defined(int)#define RETURN_MAIN int#endifchar s[12][50010];int sum[12][50010], rmax[12][50010];map&lt;vi, vi&gt; mp;RETURN_MAIN main() &#123;    int k = read(), n = read();    for (int i = 1; i &lt;= k; i++) scanf(&quot;%s&quot;, s[i] + 1);    for (int i = 1; i &lt;= k; i++)        for (int j = 1; j &lt;= n; j++) &#123;            if (s[i][j] == &#x27;(&#x27;) sum[i][j] = sum[i][j - 1] + 1;            else sum[i][j] = sum[i][j - 1] - 1;        &#125;    for (int i = 1; i &lt;= k; i++) sum[i][n + 1] = -inf;    for (int i = 1; i &lt;= k; i++) &#123;        stack&lt;int&gt; st; st.push(n + 1);        for (int j = n; j &gt;= 0; j--) &#123;            while (!st.empty() &amp;&amp; sum[i][st.top()] &gt;= sum[i][j]) st.pop();            rmax[i][j] = st.top();            st.push(j);        &#125;    &#125;    for (int j = 0; j &lt;= n; j++) &#123;        vi tmp;        for (int i = 1; i &lt;= k; i++) tmp.pb(sum[i][j]);        mp[tmp].pb(j);    &#125;    int ans = 0;    for (int j = 1; j &lt;= n; j++) &#123;        int R = inf;        for (int i = 1; i &lt;= k; i++) R = min(R, rmax[i][j - 1] - 1);        // R 为能达到的最远点        vi tmp;        for (int i = 1; i &lt;= k; i++) tmp.pb(sum[i][j - 1]);        if (R &lt;= j) continue;        vi pos = mp[tmp];        int vl = lower_bound(all(pos), j) - pos.begin(),             vr = upper_bound(all(pos), R) - pos.begin();        ans += vr - vl;    &#125;    cout &lt;&lt; ans;    return 0;&#125;","categories":["洛谷题解"],"tags":["题解","USACO","洛谷"]},{"title":"SP10228题解","url":"/2022/07/06/solution-sp10228/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n因为题目输入格式，输出格式和数据范围没给全。所以我补充一下。\n\n题目翻译\n输入格式\n第一行输入 TTT 表示有 TTT 组数据。每组数据中第一行两个整数 R,CR,CR,C ，接下来输入一个 RRR 行 CCC 列的网格 SSS ，如果 Si,j&lt;0S_{i,j} &lt; 0Si,j​&lt;0 表示恐龙，否则表示药水。\n输出格式\n输出包含 TTT 组数据，每组数据输出一个正整数，表示由单元格 1,11,11,1 到单元格 R,CR,CR,C 的最小力量值。\n数据范围与约定\n1≤T≤51 \\leq T \\leq 51≤T≤5\n2≤R,C≤5002 \\leq R,C \\leq 5002≤R,C≤500\n−103≤Si,j≤103-10^3 \\leq S_{i,j} \\leq 10^3−103≤Si,j​≤103\nS1,1=SR,C=0S_{1,1} = S_{R,C} = 0S1,1​=SR,C​=0\n下面回归正轨\n\n解题思路\n这道题是一道明显的 dp 题。\n定义状态：\ndpi,jdp_{i,j}dpi,j​ 表示从第 iii 行第 jjj 列走到第 RRR 行第 CCC 列所需最小体力值。\n初始状态：\ndpR,C=1dp_{R,C} = 1dpR,C​=1 ，因为 SR,C=0S_{R,C} = 0SR,C​=0 且体力值必须为正数，所以最小值是 111 。\n最终解：\ndp1,1dp_{1,1}dp1,1​ ，从第 111 行第 111 列走到第 RRR 行第 CCC 列所需最小体力值。\n状态转移：\n经过我们前面的分析，我们明白了这是一个逆向 dp。我们从终点往起点推，这一步需要的点数就是下面一步要用的点数的 min⁡\\minmin ，加上当前需要的消耗 (减去获得的体力)，且不能小于 111 ，因为最少是 111 ，小于就 game over 了。\n转移方程：\ndpi,j={max⁡(1,dpi,j+1−Si,j) i=Rmax⁡(1,dpi+1,j−Si,j) j=Cmax⁡(1,min⁡(dpi+1,j,dpi,j+1)−Si,j)dp_{i,j}=\\left\\{\n\\begin{aligned}\n\\max(1,dp_{i,j+1}-S_{i,j})\\ i=R\\\\\n\\max(1,dp_{i+1,j}-S_{i,j})\\ j=C\\\\\n\\max(1,\\min(dp_{i+1,j},dp_{i,j+1})-S_{i,j})\n\\end{aligned}\n\\right.\ndpi,j​=⎩⎪⎪⎨⎪⎪⎧​max(1,dpi,j+1​−Si,j​) i=Rmax(1,dpi+1,j​−Si,j​) j=Cmax(1,min(dpi+1,j​,dpi,j+1​)−Si,j​)​\n核心 Code：\ndp[i][j]=1;for(int i=r;i&gt;0;i--)&#123;\t\t\tfor(int j=c;j&gt;0;j--)&#123;\t\t\t\tif(i==r&amp;&amp;j==c)&#123;\t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t\telse if(i==r)&#123;\t\t\t\t\tdp[i][j]=max(1,dp[i][j+1]-a[i][j]);\t\t\t\t&#125;\t\t\t\telse if(j==c)&#123;\t\t\t\t\tdp[i][j]=max(1,dp[i+1][j]-a[i][j]);\t\t\t\t&#125;\t\t\t\telse&#123;\t\t\t\t\tdp[i][j]=max(1,min(dp[i][j+1],dp[i+1][j])-a[i][j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\n","categories":["洛谷题解"]},{"title":"UVA1149题解","url":"/2021/12/25/solution-uva1149/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n看一眼算法标签就知道了是贪心\n\nps:文章翻译有些错误\n\n最后一行是包裹的容量\n\n应该是\n\n第二行是包裹的容量\n\n解题思路\n\n\n对物品数组按体积由大往小排序\n\n\n用两个变量当前指针和后指针\n\n\n如果第一个和最后一个能装到箱子里，计数器 +1+1+1 ，前指针向后挪一位，后指针向前挪一位。否则只能装大的，计数器 +1+1+1 ，并且前指针要向后挪一位。\n\n\n重复循环直到前指针大于或等于后指针，输出结果。\n\n\n流程图(自己做的，有点丑)\n\n献上代码\n核心代码\ncin&gt;&gt;n;memset(V,0,sizeof(V));p1=1,p2=n,cnt=0;初始化cin&gt;&gt;v;for(int i=1;i&lt;=n;i++)&#123;    cin&gt;&gt;V[i];&#125;数据输入sort(V+1,V+n+1,greater&lt;int&gt;()); 排序while(true)&#123; 循环处理    if(p1==p2||p1&gt;p2)&#123; 结束了    \tcnt++;  因为还有物品没装所以++        cout&lt;&lt;cnt&lt;&lt;endl; 输出解        break;    &#125;    if(V[p1]+V[p2]&lt;=v)&#123; 装得下两个        cnt++;        p1++,p2--;    &#125;    else&#123;  只能装大的        cnt++;        p1++;    &#125;&#125;\n完整代码\n这里\nWarning:有防抄袭手段,请勿抄袭!\n谢谢！\n","categories":["洛谷题解"]},{"url":"/2025/08/08/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","content":"首先我们从朴素的多重背包转移开始分析。\n对于 dpjdp_{j}dpj​ 来说，若 wiw_iwi​ 表示第 iii 个物品的体积， viv_ivi​ 表示第 iii 个物品的价值， kkk 表示选择了几个物品，则转移方程如下：\ndpj=max⁡k=0ki{dpj,dpj−k⋅wi+k⋅vi}\\large{dp_{j}=\\max\\limits_{k=0}^{k_i} \\{ dp_{j},dp_{j-k \\cdot w_i} + k \\cdot v_i \\}}\ndpj​=k=0maxki​​{dpj​,dpj−k⋅wi​​+k⋅vi​}\n时间复杂度 O(NW∑i=1Nki)O(NW \\sum\\limits_{i=1}^{N} k_i)O(NWi=1∑N​ki​) ，显然在大数据的情况下会 TLE 。\n想要优化这个问题，我们要从转移的决策入手。\n对于每一个决策点 dpjdp_jdpj​ ，它都是从 dpj−wi,dpj−2⋅wi,dpj−3⋅wi,…,dpj−k⋅widp_{j-w_i},dp_{j-2 \\cdot w_i},dp_{j-3 \\cdot w_i} , \\ldots , dp_{j-k \\cdot w_i}dpj−wi​​,dpj−2⋅wi​​,dpj−3⋅wi​​,…,dpj−k⋅wi​​ （ kkk 是允许的最大选择数量）的决策点转移过来的，如图：\n(img)\n我们可以通过此得到一个结论，对于每一个决策点，它所有转移来的决策点都是同余的，如下：\ndpj≡dpj−wi≡dpj−2⋅wi≡dpj−3⋅wi≡⋯≡dpj−k⋅wi(mod  wi)\\large{dp_j \\equiv dp_{j-w_i} \\equiv dp_{j-2\\cdot w_i} \\equiv dp_{j-3\\cdot w_i} \\equiv\\cdots \\equiv dp_{j-k \\cdot w_i} (\\mod w_{i})}\ndpj​≡dpj−wi​​≡dpj−2⋅wi​​≡dpj−3⋅wi​​≡⋯≡dpj−k⋅wi​​(modwi​)\n显然，对于决策点 dpj+i(1≤i≤wi)dp_{j+i} (1 \\leq i \\leq w_i)dpj+i​(1≤i≤wi​) ，以上结论同样适用：\ndpj+i≡dpj+i−wi≡dpj+i−2⋅wi≡dpj+i−3⋅wi≡⋯≡dpj+i−k⋅wi(mod  wi)\\large{dp_{j+i} \\equiv dp_{j+i-w_i} \\equiv dp_{j+i-2\\cdot w_i} \\equiv dp_{j+i-3\\cdot w_i} \\equiv\\cdots \\equiv dp_{j+i-k \\cdot w_i} (\\mod w_{i})}\ndpj+i​≡dpj+i−wi​​≡dpj+i−2⋅wi​​≡dpj+i−3⋅wi​​≡⋯≡dpj+i−k⋅wi​​(modwi​)\n可以分析出，这个问题可以用单调队列维护最值。\n经过优化后的时间复杂度为 O(N⋅wi⋅Wwi)=O(NW)O(N \\cdot w_i \\cdot\\frac{W}{w_i})=O(NW)O(N⋅wi​⋅wi​W​)=O(NW) ，高效了很多。\n"},{"title":"UVA483题解","url":"/2021/02/26/solution-uva483/","content":"本文同步发于洛谷博客，您也可以在题解页面访问。\n题目传送门\n\n水题\n看不懂stringstream，所以用了这种方法，【分析】可以直接用cin&gt;&gt;…读入。（cin遇到空格，回车，TAB停止读入\n实现方法：\n看个例子： I love you.会读入I 和 love 和 you.\n怎么实现？直接用\nstring s;while(cin&gt;&gt;s)&#123;\t/*语句段*/&#125;\n它会一直读入数据，直到EOF（输入中止结束符）\n百科\nhttps://baike.baidu.com/item/EOF/1017800?fr=aladdin\n模拟:（以I love you.为例：\n首先读入I，遇到空格，执行语句段，然后读入love……最后读入you.遇到EOF，结束。\nreverse(s.begin(),s.end());：reverse：定义在&lt;algorithm&gt;中，指将字符串、数组等反转，s.begin和s.end是两个广义指针，分别指向s的开头和末尾。\n介绍一下getchar:\ngetchar原本的意思指读入一个字符，在这里可以把两个字符串之间的空格/回车”吃掉“，示例如下：\n\n之后怎么办？输出就好了。\nCODE：：\n#include&lt;iostream&gt;#include&lt;string&gt; //string类型用#include&lt;cstdio&gt; //geichar()用#include&lt;algorithm&gt; //reverse()用//并不向初学者推荐使用万能头，我们要明白每个头文件有什么用途。using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        reverse(s.begin(),s.end());        cout&lt;&lt;s;        char ch=getchar();        cout&lt;&lt;ch;    &#125;    return 0;&#125;\nUpdate：\n2021.5.29 重新编写对getchar的定义。\n","categories":["洛谷题解"]}]